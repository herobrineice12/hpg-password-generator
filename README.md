# HPG Password Generator

Welcome to my project!

## Definition

**HPG Password Generator** (HPG is a redundant acronym for “Herobrineice12’s Password Generator”) is a user-first, no-storage, offline, portable Python script made with the intention of generating passwords with cryptographic levels of security; every password you generate on it can be reproduced with the same exact keys you desire. The principal purpose of this application is to give the user all the control he wants over his passwords.

It also can be installed as a console application script, so you can integrate it with your operating system, which unlocks possibilities like running it with a keyboard shortcut or with an executable application.

## Features

- Completely offline.
- Totally portable with docker implementation.
- No password storing for better security.
- Reproducible password generation with 5 keys (1 context, 3 keys, 1 Master password).
- Option for choosing how many keys you want to use for the password.
- Random hash generation with a message key and prime number generator.
- Persistent configurations.
- Language options (English, Portuguese, Russian).
- Different decoding base options (Base 85, 64, 64-URL, 16).
- Option to hide your inputs with safe mode.
- Capability of limiting the length of your password.
- Automatic copying mechanism for clipboard.
- Possibility to change how the algorithms interact
- Capability to edit the current algorithm parameters

## How it works

This script achieves its functionality by using a combination of well-known algorithms in the security industry, such as Argon2 and Blake, for key and password derivation. Let me tell you how this script does it.

### Password generator

Firstly, the app will ask you for a **context**; that means where the password will be used. This input will then be encoded into a byte array and used as a salt for the intermediary keys. I personally recommend using the name of the application, service, or site you’re using.

Secondly, it will ask you for the **intermediary keys**. These keys are used to create a supersalt, which will be used in the derivation of the master key. There are no restrictions on what the keys should be, leaving that for the user.

And finally, it will ask you for the **master key**. This is the most important input because it’s the last one to be encoded and used in the algorithm. I recommend you use the most complicated input you can write in this field for better security. This piece can also be substituted by a completely random hash generated by the hash generator.

### Hash generator

The **hash generator** is a generator that uses a custom library or a foreign function made in the Golang language for creating a random key. When you use it, it will firstly ask you for a number (of bits) of possible calculations to be done by the algorithm, then it will ask you for an optional message to be used in the hash derivation. The result will not be shown after calculating, but it will be displayed after generating a password.

The **prime generation** is firstly started with a random start point in the range of the provided bits, if any. It will add 1 to the start point so we can only work with odd numbers and save 1 modulus instruction for not using `number % 2 == 0`. The second step involves an initial filtration; an array of numbers will be instantiated with only the numbers that are not divisible by 3, 5, and 7; I personally call them primitive numbers. The third step is deciding if the available candidates are sufficient to compensate for the cost of calling a foreign function interface. If the workload is bigger than 16 bits, a complex pipeline of operations by a successful coordination between Golang and Fortran is called for, with buffer prediction and workload division between available load above, but not disregarding the number of logical cores in your CPU. If the current workload is lower than 16 bits, a C-made FFI will be called instead with simple calculation and dynamic memory allocation.

The **Golang** language was chosen to be the workload orchestrator because of its speed and simplicity. It receives the array alongside its length and calculates the amount of threads that fit the most based on the actual quantity of items in the array and the number of cores on your CPU. After calculating the amount of threads necessary, it divides the array into different sections, calculates the buffer based on Ross's formula, and sends them to Fortran via C call.

The **Fortran** language was picked for its reputation in high-performance computing and for its simplicity to the compiler; it allows aggressive optimizations like loop unrolling, which happens a lot in these algorithms, to be done. Its functionality is made possible because of the 7 arguments needed to start the array processing; amongst them is:

* The address of the original array start point
* The length of Go's subdivision
* The size of the predicted buffer
* The pointer to the output array
* The size of the output array
* A flag that determines if the buffer was overflown during processing
* The index at which the array should start in case of a buffer resize

The **C** language was chosen for lower workloads because of its FFI simplicity and forwardness; a really simple implementation avoids thread calculation, workload division, and Fortran calls. It also uses dynamic allocation while calculating the primes, which isn't ideal, but it works for now.

## History

This project was born to resolve a problem that I myself found stuck with, that is, a way to create complex reproducible passwords without the need for storing the output on an online service or an offline device, leaning only in the user capability of remembering his own keys.

This project was firstly posted in the date of July 10 of 2025, and so on, it was reformulated 2 times, your second, never released version was compatible with the first one released, but it was later deprecated in this third release in favor of better code architecture and modularity.

This version also adds the possibility for the user to edit the used KDFs (Key Derivation Functions) and its parameters for more flexible security and time cost options.

### Planning process

The planning process of re-factorization was inspired by UML diagrams that I made. I did a class and a use case diagram for a general view of the project’s architecture, as shown bellow:

![Classes diagram](diagrams/jpg/Model2!ClassDiagram_1.jpg)
Classes diagram

![Use case diagram](diagrams/jpg/Model1!UseCases_0.jpg)
Use case diagram

## Dependencies

In order to use this password generator, you’re going to need some dependencies for its functionality:

- python3 interpreter
- cffi python module
- cryptography python module
- argon2-cffi python module
- bcrypt python module
- pyperclip python module
- xclip program (Only if you are on Linux)
- pbcopy program (Only if you are on Mac)
- clip program (Only if you are on Windows)
- termux-api package (Only if you are on Android)
- pyinstaller module/program (If you want to compile it to an executable application)

You can install python by searching for it and downloading via your web browser, package manager, or application store. An example of a package manager installation is:

```bash
sudo pacman -S python3
```

To install python modules you will need to use pip, which is a python package manager for installing modules that aren’t builtin in the language. Here is an example of pip installations:

```bash
pip install cffi argon2-cffi pyperclip pyinstaller
```

If you have the `requirements.txt` file present on the `.req/` directory, you will be able to install dependencies with this next command:

```bash
pip install -r requirements.txt
```

However, in systems like Arch Linux this command can be pretty dangerous because the system may use older versions of python modules, that means that by doing this you could break your operational system. So if you’re using an Arch Linux based distro, please use pacman to install python modules.

```bash
sudo pacman -S python-cffi python-argon2-cffi python-pyperclip pyinstaller
```

## Usage

### Using python

You can start the script by running the `Main.py` file and, it will show you a menu of options for selection, it will be starting first in english, I tried to make it as self-explanatory as possible for use, so I’m open to feedback if you found something I could change.

### Compiling into an executable

As said in the definition, it also can be compiled into an executable application for better integration with your system, may it be for automation, fast access on the programs menu or for launching with a keyboard shortcut, you choose!

To compile, follow these instructions:

1. Install pyinstaller with pip or package manager
2. Go to the project folder using the terminal
3. Use the command below to initiate the compile process

```bash
pyinstaller passgen.spec
```

Done! your app will be available in the `dist/` folder for usage.

### Using a docker isolated environment

Docker is a program that helps to create packages that can be used on any device that has the docker-daemon present. One of the advantages is that it can run on an isolated envirorement, that guarantees security for the end user, and it fixes problems like dependency version mismatching.

You can learn more about it [here](https://docs.docker.com/get-started/docker-overview/), and download it [here](https://www.docker.com/products/docker-desktop/). You will also need the buildx plugin, you can take a look at it [here](https://github.com/docker/buildx)

After installing, open your terminal and use the command `cd` to move to the project folder, you will use the next command with admnistrator/root privileges to build your own docker image:

```bash
docker buildx build -t password-generator .
```

If you don't see any results after running the command, don't worry, because Docker doesn't work that way. You can check the created image with the command:

```bash
docker images
```

The first thing to be aware before using this application, is that the automatic password copy to clipboard is deactivated, that happens because, as said before, docker runs applications on an isolated envirorement that make almost impossible to implement a bridge between the docker daemon and your system clipboard with my current abilities.

To run the program, you will use this command:

```bash
docker run -it --rm password-generator
```

The `-it` flag signals that this is an interactive application and allow you to use your keyboard during use, and the `--rm` flag automatically closes the docker application after quiting the program, avoiding resource leaking.